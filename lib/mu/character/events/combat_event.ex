defmodule Mu.Character.CombatEvent do
  @moduledoc """
  Events for initiating combat
  """
  use Kalevala.Character.Event
  import Mu.Utility, only: [then_if: 3]

  alias Mu.World.Room

  alias Mu.Character.CombatView
  alias Mu.Character.MoveView
  alias Mu.Character.CommandView

  alias Mu.Character.CombatFlash

  require Logger

  @doc """
  Character receives combat request and either refuses or accepts
  """
  def request(conn, event) do
    cond do
      player?(conn.character) and player?(event.data.attacker) ->
        data = Map.put(event.data, :reason, "pvp")
        event(conn, "combat/abort", data)

      true ->
        event(conn, "combat/commit", event.data)
    end
  end

  def refuse(conn, event) do
    conn
    |> assign(:reason, event.data.reason)
    |> render(CombatView, "error")
    |> assign(:character, conn.character)
    |> prompt(CommandView, "prompt")
  end

  @doc """
  After acceptance, the arena is generated by the room and participants are moved to it
  """

  def commit(conn, event) when conn.character.room_id == event.data.from do
    conn
    |> assign(:attacker, event.data.attacker)
    |> assign(:victim, event.data.victim)
    |> render(CombatView, combat_view(conn, event))
    |> move_participants(event)
  end

  def commit(conn, event) when conn.character.id == event.data.victim.id do
    # error! room_id != room combat origin room
    abort_event = %Kalevala.Event{
      topic: "combat/abort",
      acting_character: conn.character,
      from_pid: self(),
      data: %{}
    }

    from_pid = Room.whereis(event.data.from)
    arena_pid = Room.whereis(event.data.to)
    if !is_nil(from_pid), do: send(from_pid, abort_event)
    if !is_nil(arena_pid), do: send(arena_pid, abort_event)

    conn
  end

  def commit(conn, _), do: conn

  def abort(conn, event) do
    character = conn.character

    conn =
      conn
      |> assign(:attacker, event.data.attacker)
      |> assign(:victim, event.data.victim)

    conn =
      case character.id == event.data.attacker.id do
        true ->
          conn
          |> render(CombatView, "abort/attacker")
          |> move(:from, event.data.from, MoveView, :suppress, %{})
          |> move(:to, event.data.to, CombatView, "abort/witness", %{})
          |> put_flash(:combat_data, struct(CombatFlash, in_combat?: false))

        false ->
          conn
          |> render(CombatView, "abort/witness")
          |> move(:from, event.data.from, MoveView, :suppress, %{})
          |> move(:to, event.data.to, MoveView, :suppress, %{})
      end

    conn
    |> put_character(%{character | room_id: event.data.to})
    |> unsubscribe("rooms:#{event.data.from}", [], &unsubscribe_error/2)
    |> subscribe("rooms:#{event.data.to}", [], &subscribe_error/2)
    |> event("room/look")
  end

  defp move_participants(conn, event) do
    id = conn.character.id
    attacker_or_victim? = id == event.data.attacker.id or id == event.data.victim.id
    aggressive_monster? = npc?(conn.character) and conn.character.meta.aggressive?

    case attacker_or_victim? or aggressive_monster? do
      true ->
        conn
        |> enter_arena(event, attacker_or_victim?)
        |> put_character(%{conn.character | room_id: event.data.to})
        |> unsubscribe("rooms:#{event.data.from}", [], &unsubscribe_error/2)
        |> subscribe("rooms:#{event.data.to}", [], &subscribe_error/2)
        |> put_flash(:combat_data, %CombatFlash{})

      false ->
        conn
        |> assign(:character, conn.character)
        |> prompt(CommandView, "prompt")
    end
  end

  defp enter_arena(conn, event, attacker_or_victim?) do
    team = get_team(conn, event)
    join_event = build_join_event(conn, event, team)

    case attacker_or_victim? do
      true ->
        # attacker or victim
        conn
        |> move(:from, event.data.from, MoveView, :suppress, %{})
        |> move(:to, event.data.to, MoveView, :suppress, join_event)

      false ->
        # aggressive monster
        conn
        |> move(:from, event.data.from, CombatView, "combat/join", join_event)
        |> move(:to, event.data.to, CombatView, "combat/join", join_event)
    end
  end

  defp build_join_event(conn, event, team) do
    data =
      event.data
      |> Map.take([:attacker, :victim])
      |> Map.put(:team, team)

    %Kalevala.Event{
      acting_character: conn.character,
      topic: "arena/join/commit",
      from_pid: conn.character.pid,
      data: data
    }
  end

  defp get_team(conn, event) do
    case {npc?(conn.character), npc?(event.data.attacker)} do
      {true, true} -> :attackers
      {true, false} -> :defenders
      {false, false} -> :attackers
      {false, true} -> :defenders
    end
  end

  defp combat_view(conn, event) do
    cond do
      conn.character.id == event.data.attacker.id -> "init/attacker"
      conn.character.id == event.data.victim.id -> "init/victim"
      true -> "init/witness"
    end
  end

  defp player?(character), do: !npc?(character)
  defp npc?(character), do: match?(%Mu.Character.NonPlayerMeta{}, character.meta)

  def unsubscribe_error(conn, error) do
    Logger.error("Tried to unsubscribe from the old room and failed - #{inspect(error)}")

    conn
  end

  def subscribe_error(conn, error) do
    Logger.error("Tried to subscribe to the new room and failed - #{inspect(error)}")

    conn
  end
end
